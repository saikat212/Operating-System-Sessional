diff --git a/Makefile b/Makefile
index 09d790c..43fb84a 100644
--- a/Makefile
+++ b/Makefile
@@ -181,6 +181,7 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_testMem\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -217,7 +218,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 2
+CPUS := 1
 endif
 QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
@@ -248,7 +249,7 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 # check in that version.
 
 EXTRA=\
-	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c testMem.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
diff --git a/defs.h b/defs.h
index 82fb982..ac7e35f 100644
--- a/defs.h
+++ b/defs.h
@@ -52,6 +52,11 @@ struct inode*   nameiparent(char*, char*);
 int             readi(struct inode*, char*, uint, uint);
 void            stati(struct inode*, struct stat*);
 int             writei(struct inode*, char*, uint, uint);
+int             createSwapFile(struct proc* p);
+int             readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size);
+int             writeToSwapFile(struct proc* p, char* buffer, uint placeOnFile, uint size);
+int             removeSwapFile(struct proc* p);
+
 
 // ide.c
 void            ideinit(void);
@@ -121,9 +126,16 @@ int             wait(void);
 void            wakeup(void*);
 void            yield(void);
 
+
+
 // swtch.S
 void            swtch(struct context**, struct context*);
 
+// sysfile
+struct inode*   create(char *path, short type, short major, short minor);
+int             isdirempty(struct inode *dp);
+
+
 // spinlock.c
 void            acquire(struct spinlock*);
 void            getcallerpcs(void*, uint*);
@@ -186,5 +198,10 @@ void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);
 
+
+pte_t *         walkpgdirForProc(pde_t *,const void *,int);
+void deallocVersion(pde_t *pgdir, uint oldsz, uint newsz);
+
+
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/exec.c b/exec.c
index b40134f..46ccc79 100644
--- a/exec.c
+++ b/exec.c
@@ -19,6 +19,8 @@ exec(char *path, char **argv)
   pde_t *pgdir, *oldpgdir;
   struct proc *curproc = myproc();
 
+  deallocVersion(curproc->pgdir, curproc->sz, curproc->pagesHeadInMemory->pg.virtualAddr);
+
   begin_op();
 
   if((ip = namei(path)) == 0){
diff --git a/fs.c b/fs.c
index f77275f..4966e79 100644
--- a/fs.c
+++ b/fs.c
@@ -668,3 +668,144 @@ nameiparent(char *path, char *name)
 {
   return namex(path, 1, name);
 }
+
+// NEW FOR PAGING
+
+#include "fcntl.h"
+#define DIGITS 14
+
+char* itoa(int i, char b[]){
+    char const digit[] = "0123456789";
+    char* p = b;
+    if(i<0){
+        *p++ = '-';
+        i *= -1;
+    }
+    int shifter = i;
+    do{ //Move to where representation ends
+        ++p;
+        shifter = shifter/10;
+    }while(shifter);
+    *p = '\0';
+    do{ //Move back, inserting digits as u go
+        *--p = digit[i%10];
+        i = i/10;
+    }while(i);
+    return b;
+}
+
+//remove swap file of proc p;
+int
+removeSwapFile(struct proc* p)
+{
+	//path of proccess
+	char path[DIGITS];
+	memmove(path,"/.swap", 6);
+	itoa(p->pid, path+ 6);
+
+	struct inode *ip, *dp;
+	struct dirent de;
+	char name[DIRSIZ];
+	uint off;
+
+	if(0 == p->swapFile)
+	{
+		return -1;
+	}
+	fileclose(p->swapFile);
+
+	begin_op();
+	if((dp = nameiparent(path, name)) == 0)
+	{
+		end_op();
+		return -1;
+	}
+
+	ilock(dp);
+
+	  // Cannot unlink "." or "..".
+	if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+	   goto bad;
+
+	if((ip = dirlookup(dp, name, &off)) == 0)
+		goto bad;
+	ilock(ip);
+
+	if(ip->nlink < 1)
+		panic("unlink: nlink < 1");
+	if(ip->type == T_DIR && !isdirempty(ip)){
+		iunlockput(ip);
+		goto bad;
+	}
+
+	memset(&de, 0, sizeof(de));
+	if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+		panic("unlink: writei");
+	if(ip->type == T_DIR){
+		dp->nlink--;
+		iupdate(dp);
+	}
+	iunlockput(dp);
+
+	ip->nlink--;
+	iupdate(ip);
+	iunlockput(ip);
+
+	end_op();
+
+	return 0;
+
+	bad:
+		iunlockput(dp);
+		end_op();
+		return -1;
+
+}
+
+
+//return 0 on success
+int
+createSwapFile(struct proc* p)
+{
+
+	char path[DIGITS];
+	memmove(path,"/.swap", 6);
+	itoa(p->pid, path+ 6);
+
+    begin_op();
+    struct inode * in = create(path, T_FILE, 0, 0);
+	iunlock(in);
+
+	p->swapFile = filealloc();
+	if (p->swapFile == 0)
+		panic("no slot for files on /store");
+
+	p->swapFile->ip = in;
+	p->swapFile->type = FD_INODE;
+	p->swapFile->off = 0;
+	p->swapFile->readable = O_WRONLY;
+	p->swapFile->writable = O_RDWR;
+    end_op();
+
+    return 0;
+}
+
+//return as sys_write (-1 when error)
+int
+writeToSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
+{
+	p->swapFile->off = placeOnFile;
+
+	return filewrite(p->swapFile, buffer, size);
+
+}
+
+//return as sys_read (-1 when error)
+int
+readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
+{
+	p->swapFile->off = placeOnFile;
+
+	return fileread(p->swapFile, buffer,  size);
+}
+
diff --git a/mmu.h b/mmu.h
index a82d8e2..aec4420 100644
--- a/mmu.h
+++ b/mmu.h
@@ -95,6 +95,8 @@ struct segdesc {
 #define PTE_W           0x002   // Writeable
 #define PTE_U           0x004   // User
 #define PTE_PS          0x080   // Page Size
+#define PTE_A           0x020   // Accessed
+#define PTE_PG          0x200   // Paged out to secondary storage
 
 // Address in page table or page directory entry
 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
diff --git a/proc.c b/proc.c
index 806b1b1..c9ae5d6 100644
--- a/proc.c
+++ b/proc.c
@@ -7,7 +7,8 @@
 #include "proc.h"
 #include "spinlock.h"
 
-struct {
+struct
+{
   struct spinlock lock;
   struct proc proc[NPROC];
 } ptable;
@@ -20,32 +21,38 @@ extern void trapret(void);
 
 static void wakeup1(void *chan);
 
-void
-pinit(void)
+/*Added */
+void resetProcessPagesData(struct proc *p);
+void copyContentsOfProcStructs(struct proc *child);
+
+
+
+void pinit(void)
 {
   initlock(&ptable.lock, "ptable");
 }
 
 // Must be called with interrupts disabled
-int
-cpuid() {
-  return mycpu()-cpus;
+int cpuid()
+{
+  return mycpu() - cpus;
 }
 
 // Must be called with interrupts disabled to avoid the caller being
 // rescheduled between reading lapicid and running through the loop.
-struct cpu*
+struct cpu *
 mycpu(void)
 {
   int apicid, i;
-  
-  if(readeflags()&FL_IF)
+
+  if (readeflags() & FL_IF)
     panic("mycpu called with interrupts enabled\n");
-  
+
   apicid = lapicid();
   // APIC IDs are not guaranteed to be contiguous. Maybe we should have
   // a reverse map, or reserve a register to store &cpus[i].
-  for (i = 0; i < ncpu; ++i) {
+  for (i = 0; i < ncpu; ++i)
+  {
     if (cpus[i].apicid == apicid)
       return &cpus[i];
   }
@@ -54,8 +61,9 @@ mycpu(void)
 
 // Disable interrupts so that we are not rescheduled
 // while reading proc from the cpu structure
-struct proc*
-myproc(void) {
+struct proc *
+myproc(void)
+{
   struct cpu *c;
   struct proc *p;
   pushcli();
@@ -65,12 +73,12 @@ myproc(void) {
   return p;
 }
 
-//PAGEBREAK: 32
-// Look in the process table for an UNUSED proc.
-// If found, change state to EMBRYO and initialize
-// state required to run in the kernel.
-// Otherwise return 0.
-static struct proc*
+// PAGEBREAK: 32
+//  Look in the process table for an UNUSED proc.
+//  If found, change state to EMBRYO and initialize
+//  state required to run in the kernel.
+//  Otherwise return 0.
+static struct proc *
 allocproc(void)
 {
   struct proc *p;
@@ -78,8 +86,8 @@ allocproc(void)
 
   acquire(&ptable.lock);
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == UNUSED)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if (p->state == UNUSED)
       goto found;
 
   release(&ptable.lock);
@@ -92,7 +100,8 @@ found:
   release(&ptable.lock);
 
   // Allocate kernel stack.
-  if((p->kstack = kalloc()) == 0){
+  if ((p->kstack = kalloc()) == 0)
+  {
     p->state = UNUSED;
     return 0;
   }
@@ -100,33 +109,36 @@ found:
 
   // Leave room for trap frame.
   sp -= sizeof *p->tf;
-  p->tf = (struct trapframe*)sp;
+  p->tf = (struct trapframe *)sp;
 
   // Set up new context to start executing at forkret,
   // which returns to trapret.
   sp -= 4;
-  *(uint*)sp = (uint)trapret;
+  *(uint *)sp = (uint)trapret;
 
   sp -= sizeof *p->context;
-  p->context = (struct context*)sp;
+  p->context = (struct context *)sp;
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
 
+  /* Added */
+  // init paging_meta_data array and structs
+  resetProcessPagesData(p);
+
   return p;
 }
 
-//PAGEBREAK: 32
-// Set up first user process.
-void
-userinit(void)
+// PAGEBREAK: 32
+//  Set up first user process.
+void userinit(void)
 {
   struct proc *p;
   extern char _binary_initcode_start[], _binary_initcode_size[];
 
   p = allocproc();
-  
+
   initproc = p;
-  if((p->pgdir = setupkvm()) == 0)
+  if ((p->pgdir = setupkvm()) == 0)
     panic("userinit: out of memory?");
   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
   p->sz = PGSIZE;
@@ -137,7 +149,7 @@ userinit(void)
   p->tf->ss = p->tf->ds;
   p->tf->eflags = FL_IF;
   p->tf->esp = PGSIZE;
-  p->tf->eip = 0;  // beginning of initcode.S
+  p->tf->eip = 0; // beginning of initcode.S
 
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
@@ -155,18 +167,20 @@ userinit(void)
 
 // Grow current process's memory by n bytes.
 // Return 0 on success, -1 on failure.
-int
-growproc(int n)
+int growproc(int n)
 {
   uint sz;
   struct proc *curproc = myproc();
 
   sz = curproc->sz;
-  if(n > 0){
-    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+  if (n > 0)
+  {
+    if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
       return -1;
-  } else if(n < 0){
-    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+  }
+  else if (n < 0)
+  {
+    if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
       return -1;
   }
   curproc->sz = sz;
@@ -177,20 +191,21 @@ growproc(int n)
 // Create a new process copying p as the parent.
 // Sets up stack to return as if from system call.
 // Caller must set state of returned proc to RUNNABLE.
-int
-fork(void)
+int fork(void)
 {
   int i, pid;
   struct proc *np;
   struct proc *curproc = myproc();
 
   // Allocate process.
-  if((np = allocproc()) == 0){
+  if ((np = allocproc()) == 0)
+  {
     return -1;
   }
 
   // Copy process state from proc.
-  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+  if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0)
+  {
     kfree(np->kstack);
     np->kstack = 0;
     np->state = UNUSED;
@@ -200,11 +215,17 @@ fork(void)
   np->parent = curproc;
   *np->tf = *curproc->tf;
 
+  // Copy contents of swapFile / list / array from parent to child
+  if (curproc && curproc->pid > 2)
+  {
+    copyContentsOfProcStructs(np);
+  }
+
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
 
-  for(i = 0; i < NOFILE; i++)
-    if(curproc->ofile[i])
+  for (i = 0; i < NOFILE; i++)
+    if (curproc->ofile[i])
       np->ofile[i] = filedup(curproc->ofile[i]);
   np->cwd = idup(curproc->cwd);
 
@@ -224,19 +245,20 @@ fork(void)
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
-void
-exit(void)
+void exit(void)
 {
   struct proc *curproc = myproc();
   struct proc *p;
   int fd;
 
-  if(curproc == initproc)
+  if (curproc == initproc)
     panic("init exiting");
 
   // Close all open files.
-  for(fd = 0; fd < NOFILE; fd++){
-    if(curproc->ofile[fd]){
+  for (fd = 0; fd < NOFILE; fd++)
+  {
+    if (curproc->ofile[fd])
+    {
       fileclose(curproc->ofile[fd]);
       curproc->ofile[fd] = 0;
     }
@@ -247,16 +269,24 @@ exit(void)
   end_op();
   curproc->cwd = 0;
 
+   if (curproc->swapFile != 0 )
+  {
+      removeSwapFile(curproc);
+      curproc->swapFile = 0;
+  }
+
   acquire(&ptable.lock);
 
   // Parent might be sleeping in wait().
   wakeup1(curproc->parent);
 
   // Pass abandoned children to init.
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->parent == curproc){
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->parent == curproc)
+    {
       p->parent = initproc;
-      if(p->state == ZOMBIE)
+      if (p->state == ZOMBIE)
         wakeup1(initproc);
     }
   }
@@ -269,22 +299,24 @@ exit(void)
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
-int
-wait(void)
+int wait(void)
 {
   struct proc *p;
   int havekids, pid;
   struct proc *curproc = myproc();
-  
+
   acquire(&ptable.lock);
-  for(;;){
+  for (;;)
+  {
     // Scan through table looking for exited children.
     havekids = 0;
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->parent != curproc)
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+      if (p->parent != curproc)
         continue;
       havekids = 1;
-      if(p->state == ZOMBIE){
+      if (p->state == ZOMBIE)
+      {
         // Found one.
         pid = p->pid;
         kfree(p->kstack);
@@ -301,39 +333,41 @@ wait(void)
     }
 
     // No point waiting if we don't have any children.
-    if(!havekids || curproc->killed){
+    if (!havekids || curproc->killed)
+    {
       release(&ptable.lock);
       return -1;
     }
 
     // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+    sleep(curproc, &ptable.lock); // DOC: wait-sleep
   }
 }
 
-//PAGEBREAK: 42
-// Per-CPU process scheduler.
-// Each CPU calls scheduler() after setting itself up.
-// Scheduler never returns.  It loops, doing:
-//  - choose a process to run
-//  - swtch to start running that process
-//  - eventually that process transfers control
-//      via swtch back to the scheduler.
-void
-scheduler(void)
+// PAGEBREAK: 42
+//  Per-CPU process scheduler.
+//  Each CPU calls scheduler() after setting itself up.
+//  Scheduler never returns.  It loops, doing:
+//   - choose a process to run
+//   - swtch to start running that process
+//   - eventually that process transfers control
+//       via swtch back to the scheduler.
+void scheduler(void)
 {
   struct proc *p;
   struct cpu *c = mycpu();
   c->proc = 0;
-  
-  for(;;){
+
+  for (;;)
+  {
     // Enable interrupts on this processor.
     sti();
 
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+      if (p->state != RUNNABLE)
         continue;
 
       // Switch to chosen process.  It is the process's job
@@ -351,7 +385,6 @@ scheduler(void)
       c->proc = 0;
     }
     release(&ptable.lock);
-
   }
 }
 
@@ -362,19 +395,18 @@ scheduler(void)
 // be proc->intena and proc->ncli, but that would
 // break in the few places where a lock is held but
 // there's no process.
-void
-sched(void)
+void sched(void)
 {
   int intena;
   struct proc *p = myproc();
 
-  if(!holding(&ptable.lock))
+  if (!holding(&ptable.lock))
     panic("sched ptable.lock");
-  if(mycpu()->ncli != 1)
+  if (mycpu()->ncli != 1)
     panic("sched locks");
-  if(p->state == RUNNING)
+  if (p->state == RUNNING)
     panic("sched running");
-  if(readeflags()&FL_IF)
+  if (readeflags() & FL_IF)
     panic("sched interruptible");
   intena = mycpu()->intena;
   swtch(&p->context, mycpu()->scheduler);
@@ -382,10 +414,9 @@ sched(void)
 }
 
 // Give up the CPU for one scheduling round.
-void
-yield(void)
+void yield(void)
 {
-  acquire(&ptable.lock);  //DOC: yieldlock
+  acquire(&ptable.lock); // DOC: yieldlock
   myproc()->state = RUNNABLE;
   sched();
   release(&ptable.lock);
@@ -393,14 +424,14 @@ yield(void)
 
 // A fork child's very first scheduling by scheduler()
 // will swtch here.  "Return" to user space.
-void
-forkret(void)
+void forkret(void)
 {
   static int first = 1;
   // Still holding ptable.lock from scheduler.
   release(&ptable.lock);
 
-  if (first) {
+  if (first)
+  {
     // Some initialization functions must be run in the context
     // of a regular process (e.g., they call sleep), and thus cannot
     // be run from main().
@@ -414,15 +445,14 @@ forkret(void)
 
 // Atomically release lock and sleep on chan.
 // Reacquires lock when awakened.
-void
-sleep(void *chan, struct spinlock *lk)
+void sleep(void *chan, struct spinlock *lk)
 {
   struct proc *p = myproc();
-  
-  if(p == 0)
+
+  if (p == 0)
     panic("sleep");
 
-  if(lk == 0)
+  if (lk == 0)
     panic("sleep without lk");
 
   // Must acquire ptable.lock in order to
@@ -431,8 +461,9 @@ sleep(void *chan, struct spinlock *lk)
   // guaranteed that we won't miss any wakeup
   // (wakeup runs with ptable.lock locked),
   // so it's okay to release lk.
-  if(lk != &ptable.lock){  //DOC: sleeplock0
-    acquire(&ptable.lock);  //DOC: sleeplock1
+  if (lk != &ptable.lock)
+  {                        // DOC: sleeplock0
+    acquire(&ptable.lock); // DOC: sleeplock1
     release(lk);
   }
   // Go to sleep.
@@ -445,28 +476,28 @@ sleep(void *chan, struct spinlock *lk)
   p->chan = 0;
 
   // Reacquire original lock.
-  if(lk != &ptable.lock){  //DOC: sleeplock2
+  if (lk != &ptable.lock)
+  { // DOC: sleeplock2
     release(&ptable.lock);
     acquire(lk);
   }
 }
 
-//PAGEBREAK!
-// Wake up all processes sleeping on chan.
-// The ptable lock must be held.
+// PAGEBREAK!
+//  Wake up all processes sleeping on chan.
+//  The ptable lock must be held.
 static void
 wakeup1(void *chan)
 {
   struct proc *p;
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if (p->state == SLEEPING && p->chan == chan)
       p->state = RUNNABLE;
 }
 
 // Wake up all processes sleeping on chan.
-void
-wakeup(void *chan)
+void wakeup(void *chan)
 {
   acquire(&ptable.lock);
   wakeup1(chan);
@@ -476,17 +507,18 @@ wakeup(void *chan)
 // Kill the process with the given pid.
 // Process won't exit until it returns
 // to user space (see trap in trap.c).
-int
-kill(int pid)
+int kill(int pid)
 {
   struct proc *p;
 
   acquire(&ptable.lock);
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->pid == pid){
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->pid == pid)
+    {
       p->killed = 1;
       // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
+      if (p->state == SLEEPING)
         p->state = RUNNABLE;
       release(&ptable.lock);
       return 0;
@@ -496,10 +528,10 @@ kill(int pid)
   return -1;
 }
 
-//PAGEBREAK: 36
-// Print a process listing to console.  For debugging.
-// Runs when user types ^P on console.
-// No lock to avoid wedging a stuck machine further.
+// PAGEBREAK: 36
+//  Print a process listing to console.  For debugging.
+//  Runs when user types ^P on console.
+//  No lock to avoid wedging a stuck machine further.
 void
 procdump(void)
 {
@@ -516,6 +548,12 @@ procdump(void)
   char *state;
   uint pc[10];
 
+ 
+  int j,k,cnt = 0;
+  uint pagetables[20];
+  int virtualAddress[20];
+  int virtualAddressIndex = 0;
+
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
     if(p->state == UNUSED)
       continue;
@@ -529,6 +567,161 @@ procdump(void)
       for(i=0; i<10 && pc[i] != 0; i++)
         cprintf(" %p", pc[i]);
     }
+
+
+    cprintf("\nPage tables:\n");
+    cprintf("       Memory Location of page directory = %d\n",V2P(p->pgdir));
+    cnt = 0;
+     
+    for(j=0;j<512;j++){
+    virtualAddressIndex =0;
+      int isAccess = (PTE_FLAGS(p->pgdir[j]) & PTE_A ) ;
+      int isUser = (PTE_FLAGS(p->pgdir[j]) & PTE_U) ;
+      if(isAccess && isUser) {
+
+            pte_t* ptable = (pte_t*) PTE_ADDR(p->pgdir[j]);
+            cprintf("       pdir PTE %d,%d:\n",j,(uint)ptable/4096);
+            cprintf("               Memory location of page table = %d\n",ptable);
+            for(k=0;k<NPTENTRIES;k++) {
+
+              pte_t* va = (pte_t*)((pte_t*)P2V(ptable))[k];
+              uint flags = PTE_FLAGS(va);
+              int isA = (flags & PTE_A);
+              int isU = (flags & PTE_U);
+              if(isA && isU){
+                cprintf("               ptbl PTE %d, %d, %d \n",k,(uint)va/4096,PTE_ADDR(va));
+                pagetables[cnt++]=(uint) V2P(va);
+                virtualAddress[virtualAddressIndex] = 1024*j + k;
+                virtualAddressIndex++;
+              }
+            }
+      }
+    }
+
+    cprintf("Page mappings:\n");
+    for(j=0;j<cnt;j++){
+      
+      cprintf("%d -> %d\n",virtualAddress[j],(V2P(pagetables[j]))/4096);
+
+    }
     cprintf("\n");
   }
 }
+
+/*****************************  Reset process's page structs (in case oldsz in allocuvm is 0) *****************************/
+
+void resetProcessPagesData(struct proc *p)
+{
+  for (int i = 0; i < MAX_TOTAL_PAGES; i++)
+  {
+    p->pagingMetaData[i].pg.virtualAddr = 0xFFFFFFFF; // Initialize fake virtual address
+    p->pagingMetaData[i].pg.cntAccessedTimes = 0;     // Initialize number of time page has been accessed
+    p->pagingMetaData[i].pg.state = NOTUSED;          // Page state
+    p->pagingMetaData[i].pg.offsetInFile = -1;        // If page is in file, this field stores its offset inside the swap file
+    p->pagingMetaData[i].pg.pagesArrayIndex = i;      // The page's index in the pages array
+    p->pagingMetaData[i].next = 0;                    // Initialize page's pointer to next page in physical memory list
+    p->pagingMetaData[i].prev = 0;                    // Initialize page's pointer to previous page in physical memory list
+  }
+  p->swapFile = 0;
+  p->FilePagesCount = 0;    // Initialize number of pages stored in file counter
+  p->PhyMemPageCount = 0; // Initialize number of pages stored in physical memory
+  p->pagesHeadInMemory = 0;
+
+  p->cntPageFaults = 0;
+  p->cntPagingOutTimes = 0;
+}
+
+/*****************************  Copy swap file, linked list and array from parent to child process *****************************/
+
+struct memory_pages_stats
+{
+  uint initial_pages_number;
+  uint current_number_of_free_pages;
+  uint number_of_swap_files;
+};
+
+struct memory_pages_stats phys_mem_pages_stats;
+
+
+
+/*****************************  Print list of pages in physical memory *****************************/
+
+void printList(void)
+{
+  struct pageInMemory *temp = myproc()->pagesHeadInMemory;
+  cprintf("\n***** Printing : List for process %d ***** in physical memory\n\n",myproc()->pid);
+
+  while (temp != 0)
+  {
+
+    cprintf("%d ---> ", temp->pg.pagesArrayIndex);
+    temp = temp->next;
+  }
+  cprintf("\n***** Finished Printing List for process %d *****\n\n",myproc()->pid);
+}
+
+void copyContentsOfProcStructs(struct proc *child)
+{
+  int fileCheck;
+  uint pgIndex;
+  int placeOnFile = 0;
+  struct pageInMemory *tmp;
+  struct proc *curProc = myproc();
+
+  // Read contents of parent's swap file and write into child process swap file
+  if (curProc->pid > 2)
+  {
+    if (curProc->swapFile != 0)
+    {
+      char buffer[PGSIZE];
+
+      cprintf("\nCopying contents of father process's %d swap file into child's process %d swap file...\n\n", curProc->pid, child->pid);
+      if (child->swapFile == 0)
+      {
+        createSwapFile(child);
+        phys_mem_pages_stats.number_of_swap_files++;
+      }
+
+      memset(buffer, 0, PGSIZE);
+      while ((fileCheck = readFromSwapFile(curProc, buffer, placeOnFile * PGSIZE, PGSIZE)) != -1)
+      {
+        if ((fileCheck = writeToSwapFile(child, buffer, placeOnFile * PGSIZE, PGSIZE)) == -1)
+        {
+          cprintf("ERROR in writing at copyContentsOfProcStructs\n");
+        }
+        placeOnFile++;
+        memset(buffer, 0, PGSIZE);
+      }
+    }
+  }
+
+  // Update next and prev of child physical memory list
+  for (int i = 0; i < MAX_TOTAL_PAGES; i++)
+  {
+    child->pagingMetaData[i].pg = curProc->pagingMetaData[i].pg;
+    if (curProc->pagingMetaData[i].prev != 0)
+    {
+      tmp = curProc->pagingMetaData[i].prev;
+      pgIndex = tmp->pg.pagesArrayIndex;
+      child->pagingMetaData[i].prev = &child->pagingMetaData[pgIndex];
+    }
+    if (curProc->pagingMetaData[i].next != 0)
+    {
+      tmp = curProc->pagingMetaData[i].next;
+      pgIndex = tmp->pg.pagesArrayIndex;
+      child->pagingMetaData[i].next = &child->pagingMetaData[pgIndex];
+    }
+  }
+
+  // Set pointer to header of physical memory list in child process
+  if (curProc->pagesHeadInMemory != 0)
+  {
+    tmp = curProc->pagesHeadInMemory;
+    pgIndex = tmp->pg.pagesArrayIndex;
+    child->pagesHeadInMemory = &child->pagingMetaData[pgIndex];
+  }
+
+  // Set number of pages in file and physical memory
+  child->FilePagesCount = curProc->FilePagesCount;
+  child->PhyMemPageCount = curProc->PhyMemPageCount;
+}
diff --git a/proc.h b/proc.h
index 1647114..b48b166 100644
--- a/proc.h
+++ b/proc.h
@@ -1,3 +1,27 @@
+#define MAX_TOTAL_PAGES 30   //Maximum No. of pages for process.
+#define MAX_PSYC_PAGES 15  //maximum number of process's pages in the physical memory
+
+
+enum pageState { NOTUSED, PHYMEMORY, SWAPFILE };
+
+/*Page Struct */
+struct page
+{
+  uint virtualAddr;            //Page's Virtual Address
+  enum pageState state;       //page's state
+  int offsetInFile;           // If page exists in file, this field stores it's offset inside the swap file
+  uint pagesArrayIndex;       // Index of the page in the pages array
+  uint cntAccessedTimes;      //number of times page has been accessed
+};
+
+/* Linked list for pages , present in physical memory */
+struct pageInMemory
+{
+  struct page pg;
+  struct pageInMemory *prev, *next;  //next and previous links in list
+};
+
+
 // Per-CPU state
 struct cpu {
   uchar apicid;                // Local APIC ID
@@ -49,6 +73,17 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  //Swap file. must initiate with create swap file
+  struct file *swapFile;			//page file
+
+
+  /****** Added   ******/
+  struct pageInMemory *pagesHeadInMemory;                //Pointer to Linked List head of pages present in memory
+  struct pageInMemory pagingMetaData[MAX_TOTAL_PAGES];   //Array of Paging Meta Data
+  uint FilePagesCount;                                  //No. of pages stored in file (up to 15)
+  uint PhyMemPageCount;                               //No. of pages stored in physical memory (up to 15)
+  uint cntPageFaults;                                   //No. of page faults
+  uint cntPagingOutTimes;                               //No. of paged out
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/sysfile.c b/sysfile.c
index bfe61b7..bf3848e 100644
--- a/sysfile.c
+++ b/sysfile.c
@@ -165,7 +165,7 @@ bad:
 }
 
 // Is the directory dp empty except for "." and ".." ?
-static int
+int
 isdirempty(struct inode *dp)
 {
   int off;
@@ -238,7 +238,7 @@ bad:
   return -1;
 }
 
-static struct inode*
+struct inode*
 create(char *path, short type, short major, short minor)
 {
   struct inode *ip, *dp;
diff --git a/sysproc.c b/sysproc.c
index 0686d29..8589286 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -47,7 +47,7 @@ sys_sbrk(void)
 {
   int addr;
   int n;
-
+ // cprintf("sysproc.c : sbrk -> growproc");
   if(argint(0, &n) < 0)
     return -1;
   addr = myproc()->sz;
diff --git a/trap.c b/trap.c
index 41c66eb..8a94a65 100644
--- a/trap.c
+++ b/trap.c
@@ -8,6 +8,8 @@
 #include "traps.h"
 #include "spinlock.h"
 
+int swapPages(uint virtAddr);
+
 // Interrupt descriptor table (shared by all CPUs).
 struct gatedesc idt[256];
 extern uint vectors[];  // in vectors.S: array of 256 entry pointers
@@ -22,7 +24,7 @@ tvinit(void)
   for(i = 0; i < 256; i++)
     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
-
+  
   initlock(&tickslock, "time");
 }
 
@@ -36,6 +38,9 @@ idtinit(void)
 void
 trap(struct trapframe *tf)
 {
+  uint faultAddr = 0;
+  pte_t * pte;
+
   if(tf->trapno == T_SYSCALL){
     if(myproc()->killed)
       exit();
@@ -53,6 +58,7 @@ trap(struct trapframe *tf)
       ticks++;
       wakeup(&ticks);
       release(&tickslock);
+
     }
     lapiceoi();
     break;
@@ -77,9 +83,44 @@ trap(struct trapframe *tf)
             cpuid(), tf->cs, tf->eip);
     lapiceoi();
     break;
+   
+
+
+  case T_PGFLT:
+
+    // If SELECTION is NONE, go to default case (regular xv6 page fault)
+    if (myproc()->pid < 3)
+    {  
+      cprintf("T_PGFLT: SELECTION=NONE || init || shell\n");
+      goto pf;
+    }
+  
+    myproc()->cntPageFaults++;                           // Increment number of page faults counter
+    faultAddr = PGROUNDDOWN(rcr2());                    // Get fault address from rcr2 register
+    cprintf("REACHED PGFLT! ");
+     cprintf("\tProcess : %d Looking for entry with falutaddress: %d\n", myproc()->pid, faultAddr);
+    pte = walkpgdirForProc(myproc()->pgdir, (char*)faultAddr, 0);
+    if ((*pte & PTE_PG) == 0)
+    {
+      //printPageArray();
+      goto pf;      // This is a real Page Fault (PTE_PG is off --> page does not exist on file nor on page directory)
+    }
+
+    else
+    {   
+       // Swap pages - get the required page from the swap file and write a chosen page by policy from physical memory to the swap file instead
+       if (swapPages(faultAddr) == -1)
+       {
+          // swapPages didn't find the page in the swap file --> ERROR, shouldn't reach here because we check PTE_PG bit
+          cprintf("T_PGFLT: 'swap-pages' func didnt find the address: 0x%x in the swap file\n",faultAddr);
+          goto pf;
+       }
+    }
+    break;
 
   //PAGEBREAK: 13
   default:
+    pf:
     if(myproc() == 0 || (tf->cs&3) == 0){
       // In kernel, it must be our mistake.
       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
@@ -89,21 +130,20 @@ trap(struct trapframe *tf)
     // In user space, assume process misbehaved.
     cprintf("pid %d %s: trap %d err %d on cpu %d "
             "eip 0x%x addr 0x%x--kill proc\n",
-            myproc()->pid, myproc()->name, tf->trapno,
-            tf->err, cpuid(), tf->eip, rcr2());
+            myproc()->pid, myproc()->name, tf->trapno, tf->err, cpuid(), tf->eip, 
+            rcr2());
     myproc()->killed = 1;
   }
 
   // Force process exit if it has been killed and is in user space.
-  // (If it is still executing in the kernel, let it keep running
+  // (If it is still executing in the kernel, let it keep running 
   // until it gets to the regular system call return.)
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
     exit();
 
   // Force process to give up CPU on clock tick.
   // If interrupts were on while locks held, would need to check nlock.
-  if(myproc() && myproc()->state == RUNNING &&
-     tf->trapno == T_IRQ0+IRQ_TIMER)
+  if(myproc() && myproc()->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
     yield();
 
   // Check if the process has been killed since we yielded
diff --git a/types.h b/types.h
index e4adf64..b30d57c 100644
--- a/types.h
+++ b/types.h
@@ -2,3 +2,4 @@ typedef unsigned int   uint;
 typedef unsigned short ushort;
 typedef unsigned char  uchar;
 typedef uint pde_t;
+typedef uint pte_t;
diff --git a/vm.c b/vm.c
index 7134cff..c12e5a4 100644
--- a/vm.c
+++ b/vm.c
@@ -7,13 +7,33 @@
 #include "proc.h"
 #include "elf.h"
 
-extern char data[];  // defined by kernel.ld
-pde_t *kpgdir;  // for use in scheduler()
+/*
+    Function Declarations
+*/
+
+int writePageToFile(struct pageInMemory *pageToSwapToFile);
+int fileTomem(struct pageInMemory *pageToSwapFromFile);
+int swapPages(uint virtAddr);
+void UpdateRemoveList(struct pageInMemory *pageInList);
+int deletePage(struct pageInMemory *pageToDelete);
+void addNewPageToPhysMem(char *mem);
+int SwapOut(struct pageInMemory *pageToSwapFromMem);
+struct pageInMemory *replacePageFromPhysMem(void);
+
+
+void printList(void);
+
+
+// In case of freevm --> should use the global system page directory
+uint use_system_pgdir = 0;
+pde_t *system_pgdir;
+
+extern char data[]; // defined by kernel.ld
+pde_t *kpgdir;      // for use in scheduler()
 
 // Set up CPU's kernel segment descriptors.
 // Run once on entry on each CPU.
-void
-seginit(void)
+void seginit(void)
 {
   struct cpu *c;
 
@@ -22,9 +42,9 @@ seginit(void)
   // because it would have to have DPL_USR, but the CPU forbids
   // an interrupt from CPL=0 to DPL=3.
   c = &cpus[cpuid()];
-  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+  c->gdt[SEG_KCODE] = SEG(STA_X | STA_R, 0, 0xffffffff, 0);
   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
-  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+  c->gdt[SEG_UCODE] = SEG(STA_X | STA_R, 0, 0xffffffff, DPL_USER);
   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
   lgdt(c->gdt, sizeof(c->gdt));
 }
@@ -39,10 +59,13 @@ walkpgdir(pde_t *pgdir, const void *va, int alloc)
   pte_t *pgtab;
 
   pde = &pgdir[PDX(va)];
-  if(*pde & PTE_P){
-    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
-  } else {
-    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+  if (*pde & PTE_P)
+  {
+    pgtab = (pte_t *)P2V(PTE_ADDR(*pde));
+  }
+  else
+  {
+    if (!alloc || (pgtab = (pte_t *)kalloc()) == 0)
       return 0;
     // Make sure all those PTE_P bits are zero.
     memset(pgtab, 0, PGSIZE);
@@ -54,6 +77,13 @@ walkpgdir(pde_t *pgdir, const void *va, int alloc)
   return &pgtab[PTX(va)];
 }
 
+pte_t *
+walkpgdirForProc(pde_t *pgdir, const void *virtualAddres, int alloc)
+{
+  return walkpgdir(pgdir, virtualAddres, alloc);
+}
+
+
 // Create PTEs for virtual addresses starting at va that refer to
 // physical addresses starting at pa. va and size might not
 // be page-aligned.
@@ -63,15 +93,16 @@ mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
   char *a, *last;
   pte_t *pte;
 
-  a = (char*)PGROUNDDOWN((uint)va);
-  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
-  for(;;){
-    if((pte = walkpgdir(pgdir, a, 1)) == 0)
+  a = (char *)PGROUNDDOWN((uint)va);
+  last = (char *)PGROUNDDOWN(((uint)va) + size - 1);
+  for (;;)
+  {
+    if ((pte = walkpgdir(pgdir, a, 1)) == 0)
       return -1;
-    if(*pte & PTE_P)
+    if (*pte & PTE_P)
       panic("remap");
     *pte = pa | perm | PTE_P;
-    if(a == last)
+    if (a == last)
       break;
     a += PGSIZE;
     pa += PGSIZE;
@@ -102,33 +133,35 @@ mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
 
 // This table defines the kernel's mappings, which are present in
 // every process's page table.
-static struct kmap {
+static struct kmap
+{
   void *virt;
   uint phys_start;
   uint phys_end;
   int perm;
 } kmap[] = {
- { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space
- { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata
- { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory
- { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices
+    {(void *)KERNBASE, 0, EXTMEM, PTE_W},            // I/O space
+    {(void *)KERNLINK, V2P(KERNLINK), V2P(data), 0}, // kern text+rodata
+    {(void *)data, V2P(data), PHYSTOP, PTE_W},       // kern data+memory
+    {(void *)DEVSPACE, DEVSPACE, 0, PTE_W},          // more devices
 };
 
 // Set up kernel part of a page table.
-pde_t*
+pde_t *
 setupkvm(void)
 {
   pde_t *pgdir;
   struct kmap *k;
 
-  if((pgdir = (pde_t*)kalloc()) == 0)
+  if ((pgdir = (pde_t *)kalloc()) == 0)
     return 0;
   memset(pgdir, 0, PGSIZE);
-  if (P2V(PHYSTOP) > (void*)DEVSPACE)
+  if (P2V(PHYSTOP) > (void *)DEVSPACE)
     panic("PHYSTOP too high");
-  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
-    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
-                (uint)k->phys_start, k->perm) < 0) {
+  for (k = kmap; k < &kmap[NELEM(kmap)]; k++)
+    if (mappages(pgdir, k->virt, k->phys_end - k->phys_start,
+                 (uint)k->phys_start, k->perm) < 0)
+    {
       freevm(pgdir);
       return 0;
     }
@@ -137,8 +170,7 @@ setupkvm(void)
 
 // Allocate one page table for the machine for the kernel address
 // space for scheduler processes.
-void
-kvmalloc(void)
+void kvmalloc(void)
 {
   kpgdir = setupkvm();
   switchkvm();
@@ -146,71 +178,68 @@ kvmalloc(void)
 
 // Switch h/w page table register to the kernel-only page table,
 // for when no process is running.
-void
-switchkvm(void)
+void switchkvm(void)
 {
-  lcr3(V2P(kpgdir));   // switch to the kernel page table
+  lcr3(V2P(kpgdir)); // switch to the kernel page table
 }
 
 // Switch TSS and h/w page table to correspond to process p.
-void
-switchuvm(struct proc *p)
+void switchuvm(struct proc *p)
 {
-  if(p == 0)
+  if (p == 0)
     panic("switchuvm: no process");
-  if(p->kstack == 0)
+  if (p->kstack == 0)
     panic("switchuvm: no kstack");
-  if(p->pgdir == 0)
+  if (p->pgdir == 0)
     panic("switchuvm: no pgdir");
 
   pushcli();
   mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
-                                sizeof(mycpu()->ts)-1, 0);
+                                sizeof(mycpu()->ts) - 1, 0);
   mycpu()->gdt[SEG_TSS].s = 0;
   mycpu()->ts.ss0 = SEG_KDATA << 3;
   mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
   // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
   // forbids I/O instructions (e.g., inb and outb) from user space
-  mycpu()->ts.iomb = (ushort) 0xFFFF;
+  mycpu()->ts.iomb = (ushort)0xFFFF;
   ltr(SEG_TSS << 3);
-  lcr3(V2P(p->pgdir));  // switch to process's address space
+  lcr3(V2P(p->pgdir)); // switch to process's address space
   popcli();
 }
 
 // Load the initcode into address 0 of pgdir.
 // sz must be less than a page.
-void
-inituvm(pde_t *pgdir, char *init, uint sz)
+void inituvm(pde_t *pgdir, char *init, uint sz)
 {
   char *mem;
 
-  if(sz >= PGSIZE)
+  if (sz >= PGSIZE)
     panic("inituvm: more than a page");
   mem = kalloc();
   memset(mem, 0, PGSIZE);
-  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
+  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W | PTE_U);
   memmove(mem, init, sz);
 }
 
 // Load a program segment into pgdir.  addr must be page-aligned
 // and the pages from addr to addr+sz must already be mapped.
-int
-loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
+int loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
 {
   uint i, pa, n;
   pte_t *pte;
 
-  if((uint) addr % PGSIZE != 0)
+  if ((uint)addr % PGSIZE != 0)
     panic("loaduvm: addr must be page aligned");
-  for(i = 0; i < sz; i += PGSIZE){
-    if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
+  for (i = 0; i < sz; i += PGSIZE)
+  {
+    if ((pte = walkpgdir(pgdir, addr + i, 0)) == 0)
       panic("loaduvm: address should exist");
     pa = PTE_ADDR(*pte);
-    if(sz - i < PGSIZE)
+    if (sz - i < PGSIZE)
       n = sz - i;
     else
       n = PGSIZE;
-    if(readi(ip, P2V(pa), offset+i, n) != n)
+    if (readi(ip, P2V(pa), offset + i, n) != n)
       return -1;
   }
   return 0;
@@ -218,32 +247,54 @@ loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
 
 // Allocate page tables and physical memory to grow process from oldsz to
 // newsz, which need not be page aligned.  Returns new size or 0 on error.
-int
-allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+int allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 {
   char *mem;
   uint a;
 
-  if(newsz >= KERNBASE)
+  if (newsz >= KERNBASE)
     return 0;
-  if(newsz < oldsz)
+  if (newsz < oldsz)
     return oldsz;
 
   a = PGROUNDUP(oldsz);
-  for(; a < newsz; a += PGSIZE){
+  struct proc *curproc = myproc();
+
+  for (; a < newsz; a += PGSIZE)
+  {
+    if ((myproc()->pid >= 1) && (myproc()->PhyMemPageCount == MAX_PSYC_PAGES))
+    {
+
+        int AlreadyPagesFile = MAX_TOTAL_PAGES - MAX_PSYC_PAGES;
+        if (curproc->FilePagesCount == AlreadyPagesFile ){ 
+        
+          cprintf("allocuvm : Reached Maximum Number of Pages Per Process, Cannot Allocate More Pages!! \n");
+          return 0;
+        }
+        else if (curproc->swapFile == 0)
+        {
+          createSwapFile(myproc());
+        }
+      
+        if ( SwapOut(replacePageFromPhysMem()) == -1)
+        {
+          return 0;
+        }
+      
+    }
+
     mem = kalloc();
-    if(mem == 0){
+    // If not able to allocate physical memory to page
+    if (mem == 0)
+    {
       cprintf("allocuvm out of memory\n");
       deallocuvm(pgdir, newsz, oldsz);
       return 0;
     }
     memset(mem, 0, PGSIZE);
-    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
-      cprintf("allocuvm out of memory (2)\n");
-      deallocuvm(pgdir, newsz, oldsz);
-      kfree(mem);
-      return 0;
-    }
+    mappages(pgdir, (char *)a, PGSIZE, V2P(mem), PTE_W | PTE_U);
+    cprintf("allocuvm called .......... \n");
+    addNewPageToPhysMem((char *)a); // Add the new allocated page to physical memory
   }
   return newsz;
 }
@@ -252,64 +303,197 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 // newsz.  oldsz and newsz need not be page-aligned, nor does newsz
 // need to be less than oldsz.  oldsz can be larger than the actual
 // process size.  Returns the new process size.
-int
-deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+int deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 {
+  struct pageInMemory *pageInArray;
   pte_t *pte;
   uint a, pa;
+  int found;
 
-  if(newsz >= oldsz)
+  if (newsz >= oldsz)
     return oldsz;
 
   a = PGROUNDUP(newsz);
-  for(; a  < oldsz; a += PGSIZE){
-    pte = walkpgdir(pgdir, (char*)a, 0);
-    if(!pte)
-      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
-    else if((*pte & PTE_P) != 0){
+  struct proc *curproc = myproc();
+  for (; a < oldsz; a += PGSIZE)
+  {
+    found = 0;
+    pte = walkpgdir(pgdir, (char *)a, 0);
+    if (!pte)
+    {
+      a += (NPTENTRIES - 1) * PGSIZE;
+    }
+
+    // Entry in page table is present
+    else if ((*pte & PTE_P) != 0)
+    {
       pa = PTE_ADDR(*pte);
-      if(pa == 0)
-        panic("kfree");
+      if (pa == 0)
+      {
+        cprintf("deallocuvm: process %d is about to panic, pages in memory: %d, pages in file: %d\n", curproc->pid, curproc->PhyMemPageCount, curproc->FilePagesCount);
+        // printPageArray();
+        panic("kfree in deallocuvm");
+      }
       char *v = P2V(pa);
       kfree(v);
       *pte = 0;
+
+     
+      if (myproc()->pgdir == pgdir)
+      {
+        for (pageInArray = &curproc->pagingMetaData[0]; pageInArray < &curproc->pagingMetaData[MAX_TOTAL_PAGES]; pageInArray++)
+        {
+          if (pageInArray->pg.virtualAddr == a) 
+          {
+            found = 1;
+            break;
+          }
+        }
+        if (found == 1)
+        {
+          deletePage(pageInArray);
+        }
+      }
+    }
+
+    // Entry is not present --> checking if in swap file
+    else if ((*pte & PTE_PG) && (pgdir == curproc->pgdir))
+    {
+      uint vAddr = PTE_ADDR((uint)a);
+      for (pageInArray = &curproc->pagingMetaData[0]; pageInArray < &curproc->pagingMetaData[MAX_TOTAL_PAGES]; pageInArray++)
+      {
+        if (pageInArray->pg.virtualAddr == vAddr) // If found (according to address), break
+        {
+          found = 1;
+          break;
+        }
+      }
+
+      // Found --> initialize page's field in array
+      if (found == 1)
+      {
+        curproc->FilePagesCount--;
+        pageInArray->pg.virtualAddr = 0xFFFFFFFF;
+        pageInArray->pg.cntAccessedTimes = 0;
+        pageInArray->pg.offsetInFile = -1;
+        pageInArray->pg.state = NOTUSED;
+      }
+      *pte = 0;
     }
   }
   return newsz;
 }
 
+void deallocVersion(pde_t *pgdir, uint oldsz, uint newsz)
+{
+  pte_t *pte;
+  uint a, pa;
+
+  struct proc *curproc = myproc();
+  
+  a = PGROUNDUP(newsz);
+  for (; a <= oldsz; a += PGSIZE)
+  {
+    pte = walkpgdir(pgdir, (char *)a, 0);
+    if (!pte)
+    {
+      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+      cprintf("hello form the deallocate the file fucntion");
+    }
+
+    else if ((*pte & PTE_P) != 0)
+    {
+
+      pa = PTE_ADDR(*pte);
+      if (pa == 0)
+        panic("kfree\n The page  should have been present in during deallocation\n");
+      *pte = 0;
+
+      struct pageInMemory *pageInArray;
+      int found = 0;
+      for (pageInArray = &curproc->pagingMetaData[0]; pageInArray < &curproc->pagingMetaData[MAX_TOTAL_PAGES]; pageInArray++)
+      {
+        if (pageInArray->pg.virtualAddr == a) // If found (according to address), break
+        {
+          found = 1;
+          break;
+        }
+      }
+
+      if (found == 1)
+      {
+        if (curproc->pgdir == pgdir)
+          deletePage(pageInArray);
+        // printproclist(curproc);
+      }
+    }
+
+    else if (((*pte & PTE_PG)))
+    {
+      if (curproc->pgdir == pgdir)
+      {
+        struct pageInMemory *temphead = curproc->pagesHeadInMemory;
+
+        struct pageInMemory *pageInArray;
+        int found = 0;
+        for (pageInArray = &curproc->pagingMetaData[0]; pageInArray < &curproc->pagingMetaData[MAX_TOTAL_PAGES]; pageInArray++)
+        {
+          if (pageInArray->pg.virtualAddr == a) // If found (according to address), break
+          {
+            found = 1;
+            break;
+          }
+        }
+        if (found == 1)
+        {
+          // temphead = &curproc->pagingMetaData[i];
+          pageInArray->pg.virtualAddr = 0xFFFFFFFF;
+          pageInArray->pg.offsetInFile = -1;
+          pageInArray->pg.state = NOTUSED;
+          curproc->pagingMetaData[temphead->pg.pagesArrayIndex] = *temphead;
+          curproc->FilePagesCount--;
+        }
+        *pte = 0;
+      }
+    }
+  }
+  
+}
+
 // Free a page table and all the physical memory pages
 // in the user part.
-void
-freevm(pde_t *pgdir)
+void freevm(pde_t *pgdir)
 {
   uint i;
 
-  if(pgdir == 0)
+  if (pgdir == 0)
     panic("freevm: no pgdir");
   deallocuvm(pgdir, KERNBASE, 0);
-  for(i = 0; i < NPDENTRIES; i++){
-    if(pgdir[i] & PTE_P){
-      char * v = P2V(PTE_ADDR(pgdir[i]));
+  for (i = 0; i < NPDENTRIES; i++)
+  {
+    if (pgdir[i] & PTE_P)
+    {
+      char *v = P2V(PTE_ADDR(pgdir[i]));
       kfree(v);
     }
   }
-  kfree((char*)pgdir);
+  kfree((char *)pgdir);
 }
 
 // Clear PTE_U on a page. Used to create an inaccessible
 // page beneath the user stack.
-void
-clearpteu(pde_t *pgdir, char *uva)
+void clearpteu(pde_t *pgdir, char *uva)
 {
   pte_t *pte;
 
   pte = walkpgdir(pgdir, uva, 0);
-  if(pte == 0)
+  if (pte == 0)
     panic("clearpteu");
   *pte &= ~PTE_U;
 }
 
+// Given a parent process's page table, create a copy
+// of it for a child.
 // Given a parent process's page table, create a copy
 // of it for a child.
 pde_t*
@@ -321,22 +505,48 @@ copyuvm(pde_t *pgdir, uint sz)
   char *mem;
 
   if((d = setupkvm()) == 0)
+  {
     return 0;
-  for(i = 0; i < sz; i += PGSIZE){
+  }
+
+  // For each page in process's page directory
+  for(i = 0; i < sz; i += PGSIZE)
+  {
     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
+    {
       panic("copyuvm: pte should exist");
-    if(!(*pte & PTE_P))
-      panic("copyuvm: page not present");
+    }
+
+
+    // Case that page is not in memory, and not in swap file, should panic
+    if (!((*pte & PTE_P) || (*pte & PTE_PG)))
+    {
+      panic("copyuvm: page not present and not in swap file");
+    }
+
     pa = PTE_ADDR(*pte);
     flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
-      goto bad;
-    memmove(mem, (char*)P2V(pa), PGSIZE);
-    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
-      kfree(mem);
-      goto bad;
+
+    // Case the page is in not in file --> page is in memory, allocate regularly
+    if ((*pte & PTE_PG) == 0)
+    { 
+      if((mem = kalloc()) == 0)
+      {
+        goto bad;
+      }
+      memmove(mem, (char*)P2V(pa), PGSIZE);
+      if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0)
+        goto bad;
+    }
+
+    // (*pte & PTE_P) is not 0 --> page is in the file --> Allocate page table entry without inserting memory and mapping
+    else 
+    {
+      pte_t *filed_page_pte = walkpgdir(d, (void*) i, 1);
+      *filed_page_pte = (*pte & 0xfff);
     }
   }
+
   return d;
 
 bad:
@@ -344,38 +554,38 @@ bad:
   return 0;
 }
 
-//PAGEBREAK!
-// Map user virtual address to kernel address.
-char*
+// PAGEBREAK!
+//  Map user virtual address to kernel address.
+char *
 uva2ka(pde_t *pgdir, char *uva)
 {
   pte_t *pte;
 
   pte = walkpgdir(pgdir, uva, 0);
-  if((*pte & PTE_P) == 0)
+  if ((*pte & PTE_P) == 0)
     return 0;
-  if((*pte & PTE_U) == 0)
+  if ((*pte & PTE_U) == 0)
     return 0;
-  return (char*)P2V(PTE_ADDR(*pte));
+  return (char *)P2V(PTE_ADDR(*pte));
 }
 
 // Copy len bytes from p to user address va in page table pgdir.
 // Most useful when pgdir is not the current page table.
 // uva2ka ensures this only works for PTE_U pages.
-int
-copyout(pde_t *pgdir, uint va, void *p, uint len)
+int copyout(pde_t *pgdir, uint va, void *p, uint len)
 {
   char *buf, *pa0;
   uint n, va0;
 
-  buf = (char*)p;
-  while(len > 0){
+  buf = (char *)p;
+  while (len > 0)
+  {
     va0 = (uint)PGROUNDDOWN(va);
-    pa0 = uva2ka(pgdir, (char*)va0);
-    if(pa0 == 0)
+    pa0 = uva2ka(pgdir, (char *)va0);
+    if (pa0 == 0)
       return -1;
     n = PGSIZE - (va - va0);
-    if(n > len)
+    if (n > len)
       n = len;
     memmove(pa0 + (va - va0), buf, n);
     len -= n;
@@ -385,10 +595,445 @@ copyout(pde_t *pgdir, uint va, void *p, uint len)
   return 0;
 }
 
-//PAGEBREAK!
-// Blank page.
-//PAGEBREAK!
-// Blank page.
-//PAGEBREAK!
-// Blank page.
+// PAGEBREAK!
+//  Blank page.
+// PAGEBREAK!
+//  Blank page.
+// PAGEBREAK!
+//  Blank page.
+
+/*********************************************************************************************************/
+/******************************************** Added ******************************************************/
+
+int NOTUSEDpageFinding(struct proc *curProc, struct pageInMemory *pageInArray)
+{
+  int idx = 0;
+
+  for (pageInArray = &curProc->pagingMetaData[0]; pageInArray < &curProc->pagingMetaData[MAX_TOTAL_PAGES]; pageInArray++)
+  {
+    if (pageInArray->pg.state == NOTUSED)
+    {
+      return idx;
+    }
+    idx++;
+  }
+  return -1;
+}
+
+
+void PageInitializeInArray(struct pageInMemory *pageInArray, uint address, enum pageState state)
+{
+  pageInArray->pg.virtualAddr = (uint)address;
+  pageInArray->pg.state = state;
+  pageInArray->pg.offsetInFile = -1; // If page is in file, this field stores its offset inside the swap file
+  pageInArray->pg.cntAccessedTimes = 0;
+  pageInArray->next = 0;
+}
+
+void addNewPageToPhysMem(char *address)
+{
+  struct proc *currentProc = myproc();
+  struct pageInMemory *currentPage = currentProc->pagesHeadInMemory;
+  struct pageInMemory *PageIntoArray = 0;
+  int idx = 0, found = 0;
+
+  // head of physical memory pages is null
+  // so, set virtual address
+  if (!currentPage)
+  {
+    PageIntoArray = &currentProc->pagingMetaData[0];
+    currentProc->pagesHeadInMemory = PageIntoArray;
+  }
+  else
+  {
+    while (currentPage->next != 0)
+    {
+      currentPage = currentPage->next;
+    }
+
+    // Search for whether already exists entry
+    for (PageIntoArray = &currentProc->pagingMetaData[0]; PageIntoArray < &currentProc->pagingMetaData[MAX_TOTAL_PAGES]; PageIntoArray++)
+    {
+      if (PageIntoArray->pg.virtualAddr == PTE_ADDR((uint)address))
+      {
+        found = 1;
+        break;
+      }
+      idx++;
+    }
+
+    // If entry doesnot exist, find first page unused and Add A new Page
+    if (!found)
+    {
+      idx = NOTUSEDpageFinding(currentProc, PageIntoArray);
+      PageIntoArray = &currentProc->pagingMetaData[idx];
+    }
+
+    currentPage->next = PageIntoArray;
+    PageIntoArray->prev = currentPage;
+
+    currentProc->pagingMetaData[currentPage->pg.pagesArrayIndex] = *currentPage;
+  }
+
+  // Initialization fields of page struct
+  PageInitializeInArray(PageIntoArray, (uint)address, PHYMEMORY);
+  PageIntoArray->pg.pagesArrayIndex = idx;
+  
+ cprintf("Allocated New Page %d in Physical Memory %d\n\n", PageIntoArray->pg.pagesArrayIndex,address);
+  // Update Array Of Pages
+  currentProc->pagingMetaData[idx] = *PageIntoArray;
+  currentProc->PhyMemPageCount++;
+
+ 
+}
+
+/* Remove Page from the Physical Memory And Write to Swap File*/
+int SwapOut(struct pageInMemory *pageToSwapFromMem)
+{
+  struct proc *curProc = myproc();
+
+  // Check if should use the system global pgdir
+  pte_t *pgdir = curProc->pgdir;
+  pte_t *pte = walkpgdir(pgdir, (char *)pageToSwapFromMem->pg.virtualAddr, 0);
+
+  // Write page to swap file from page's virtual address
+  int check = writePageToFile(pageToSwapFromMem) ;
+  if (check == -1)
+  {
+    return -1;
+  }
+
+  // Remove the page from physcial memory Linked List and update corresponding lists
+  int idx = pageToSwapFromMem->pg.pagesArrayIndex;
+  UpdateRemoveList(pageToSwapFromMem);
+  curProc->pagingMetaData[pageToSwapFromMem->pg.pagesArrayIndex] = *pageToSwapFromMem;
+
+  // Update PTE_A and PTE_PG bits
+  //clear_present_set_pagedout(pgdir, (char *)pageToSwapFromMem->pg.virtualAddr);
+
+if (pte == 0)
+  {
+    panic("clear_present_set_pagedout\n");
+  }
+
+  *pte &= ~PTE_P;       // Clear PTE_P bit
+  *pte = *pte | PTE_PG; // Set PTE_PG bit -->  page is Paged Out to swap file
+
+  // clear_PTE_A(pgdir, (char *)pageToSwapFromMem->pg.virtualAddr);
+  char * virAddress = (char *)pageToSwapFromMem->pg.virtualAddr;
+   pte = walkpgdir(pgdir, virAddress, 0);
+  if (pte == 0)
+    panic("clear_PTE_A");
+  *pte &= ~PTE_A;
+
+
+  uint pAddr = PTE_ADDR(*pte);
+  char *vAddr = P2V(pAddr);
+  kfree(vAddr);
+
+  curProc->cntPagingOutTimes++;
+  curProc->PhyMemPageCount--;
+
+   cprintf("Swapping File Page No : %d\t\n", idx);
+
+  // refresh the cr3 resigster, as TLB might contain the old entry
+  lcr3(V2P(pgdir));
+
+ 
+
+  return 0;
+}
+
+/* Read Page From File */
+int SwapIn(struct pageInMemory *pageToSwapFromFile)
+{
+  
+
+  int offset = pageToSwapFromFile->pg.offsetInFile;
+  if (offset < 0)
+  {
+    cprintf("fileTomem  : Page doesnot exist in File  !!\n");
+    return -1;
+  }
+  struct proc *curProc = myproc();
+
+  // Check if we should use the system global pgdir
+  pte_t *pgdir = curProc->pgdir;
+  pte_t *pte = walkpgdir(pgdir, (void *)(PTE_ADDR(pageToSwapFromFile->pg.virtualAddr)), 0);
+  char *memInPgdir = kalloc();
+  if (memInPgdir == 0)
+  {
+    panic("FileToMem: Out of Memory !! \n");
+  }
+
+  mappages(pgdir, (char *)pageToSwapFromFile->pg.virtualAddr, PGSIZE, V2P(memInPgdir), PTE_W | PTE_U);
+  
+  if (readFromSwapFile(curProc, memInPgdir, offset, PGSIZE) == -1)
+  {
+    cprintf("FileToMem: READ FAIL !!\n");
+    return -1;
+  }
+
+  if ((pte = walkpgdir(pgdir, (void *)pageToSwapFromFile->pg.virtualAddr, 0)) == 0)
+  {
+    panic("fileToMem: PTE doesn't exist!!");
+  }
+
+  // Update PTE_A and PTE_PG bits
+
+
+  if (pte == 0)
+  {
+    panic("set_present_clear_pagedout\n");
+  }
+
+  *pte &= ~PTE_PG;     // Clear PTE_PG bit
+  *pte = *pte | PTE_P;
+
+  // Update page's fields
+  pageToSwapFromFile->pg.state = PHYMEMORY;
+  pageToSwapFromFile->pg.cntAccessedTimes = 0;
+  pageToSwapFromFile->pg.offsetInFile = -1;
+
+  // update count of files
+  curProc->FilePagesCount--;
+  curProc->PhyMemPageCount++;
+
+  // Insert page to Physical Memory / Pages Linked List
+  struct pageInMemory *lastPage = curProc->pagesHeadInMemory;
+  while (lastPage->next != 0)
+  {
+    lastPage = lastPage->next;
+  }
+  lastPage->next = pageToSwapFromFile;
+  pageToSwapFromFile->prev = lastPage;
+  pageToSwapFromFile->next = 0;
+
+
+  cprintf("Read Page %d From File .\n\n", pageToSwapFromFile->pg.virtualAddr);
+  // Update array of pages
+  curProc->pagingMetaData[lastPage->pg.pagesArrayIndex] = *lastPage;
+  curProc->pagingMetaData[pageToSwapFromFile->pg.pagesArrayIndex] = *pageToSwapFromFile;
+
+  
+
+  return 0;
+}
+
+/* Write Page to File*/
+int writePageToFile(struct pageInMemory *pageToSwapToFile)
+{
+  int offsetExists = 0;
+  struct proc *curProc = myproc();
+
+  pte_t *pgdir = curProc->pgdir;
+  pte_t *pte = walkpgdir(pgdir, (char *)pageToSwapToFile->pg.virtualAddr, 0);
+
+  if (!(*pte & PTE_P))
+  {
+    panic("writePageToFile: Page Is not Present! \n");
+  }
+  if (pte == 0)
+  {
+    panic("writePageToFile:  Page Doesn't Exist !\n");
+  }
+
+  
+
+  // Write page to swap file
+  // if offset is not 0, swap into the page's offset
+  // else swap into the end of file
+  int check;
+  if (pageToSwapToFile->pg.offsetInFile > -1)
+  {
+    offsetExists = 1;
+    check = writeToSwapFile(curProc, (char *)pageToSwapToFile->pg.virtualAddr, pageToSwapToFile->pg.offsetInFile, PGSIZE);
+    if (check == -1)
+    {
+      cprintf("ERROR in \"WritePageToFile\" First 'IF' \n");
+      return -1;
+    }
+  }
+  else if ((check = writeToSwapFile(curProc, (char *)pageToSwapToFile->pg.virtualAddr, PGSIZE * (curProc->FilePagesCount), PGSIZE)) == -1)
+  {
+    cprintf("ERROR in WritePageToFile Second 'IF' \n");
+    return -1;
+  }
+
+  // If new page into file
+  // So set offset in file
+  if (offsetExists == 0)
+  {
+    pageToSwapToFile->pg.offsetInFile = PGSIZE * (curProc->FilePagesCount);
+  }
+
+  // Set state SWAPFILE and update information
+  pageToSwapToFile->pg.state = SWAPFILE;
+  pageToSwapToFile->pg.cntAccessedTimes = 0;
+  curProc->FilePagesCount++;
+
+  // Print Status
+  cprintf("#########\n");
+  cprintf("Write Page : \n");
+  cprintf("Number of Pages In File %d . \n\n", curProc->FilePagesCount);
+  cprintf("Process %d, Wrote Page Number %x to File . ", curProc->pid, pageToSwapToFile->pg.pagesArrayIndex);
+  cprintf("\n");
+  return 0;
+}
+
+/* Choose Page to remove from physical memory pages list
+   Algorithms Implemented :
+      1. FIFO – this is the default replacement algorithm that follows the order in which the pages were created.
+*/
+struct pageInMemory *replacePageFromPhysMem(void)
+{
+  struct proc *curProc = myproc();
+  struct pageInMemory *pageToRemove = curProc->pagesHeadInMemory;
+
+  if (!pageToRemove) // List is NULL (No page to replace / swap out)
+  {
+    return 0;
+  }
+
+  cprintf("BEFORE choosing:::::Replace Page from Physical Memory :rintList:\n");
+  printList();
+
+  return pageToRemove;
+}
+
+/* Swap between page in Physical Memory and desired Page from File */
+int swapPages(uint virtualAddress)
+{
+  cprintf("Page swapping  starts here...\n");
+
+  struct proc *curproc = myproc();
+  struct pageInMemory *pageToSwapToFile = replacePageFromPhysMem(); // Get the chosen page by policy to remove from physical memory to the file
+  struct pageInMemory *pageToSwapToMem;
+
+  // Look for required page entry in paging meta data array
+  int found = 0;
+  for (pageToSwapToMem = &curproc->pagingMetaData[0]; pageToSwapToMem < &curproc->pagingMetaData[MAX_TOTAL_PAGES]; pageToSwapToMem++)
+  {
+    if (pageToSwapToMem->pg.virtualAddr == virtualAddress)
+    {
+      found = 1;
+      break;
+    }
+  }
+  if (found != 1) // If didn't find the required page, return -1 error
+  {
+    return -1;
+  }
+
+  // Update the offset where to insert page into the file to swap out
+  pageToSwapToFile->pg.offsetInFile = pageToSwapToMem->pg.offsetInFile;
+
+  // Read Page from Swap file and write the page to Swap File
+  SwapIn(pageToSwapToMem);
+  SwapOut(pageToSwapToFile);
+
+  // Set Necessary Flags
+  // set_PTE_A(curproc->pgdir, (char *)pageToSwapToMem->pg.virtualAddr);
+
+  char * virtAddr = (char *)pageToSwapToMem->pg.virtualAddr;
+  pte_t *pte = walkpgdir(myproc()->pgdir, virtAddr, 0);
+
+  if (pte == 0)
+  {
+    panic("clear_PTE_A");
+  }
+  *pte |= PTE_A;
+
+
+  cprintf("End : Page Swapping.\n");
+  cprintf("\tPage Number %d ===> File.\n", pageToSwapToFile->pg.pagesArrayIndex, pageToSwapToMem->pg.pagesArrayIndex);
+  cprintf("\tPage Number %d with virtual address %d ===> Physical Memory.\n", pageToSwapToMem->pg.virtualAddr);
+  cprintf("\n");
+  cprintf("After Swaping :: \n");
+  printList();
+  return 0;
+}
+
+/*  Update list of pages in physical memory when removing a page */
+void UpdateRemoveList(struct pageInMemory *PageIntoList)
+{
+  struct pageInMemory *nextPage;
+  struct pageInMemory *prevPage;
+  struct proc *curProc = myproc();
+
+  // Check if HEAD of list
+  if (PageIntoList->prev != 0)
+  {
+     prevPage = PageIntoList->prev;
+    prevPage->next = PageIntoList->next;
+    if (PageIntoList->next != 0) // Not head and not tail (In the middle of the list)
+    {
+      nextPage = PageIntoList->next;
+      nextPage->prev = prevPage;
+      curProc->pagingMetaData[nextPage->pg.pagesArrayIndex] = *nextPage;
+    }
+    curProc->pagingMetaData[prevPage->pg.pagesArrayIndex] = *prevPage; // Tail of list (and not head)
+  }
+  // not Head of list
+  else
+  {
+   curProc->pagesHeadInMemory = PageIntoList->next; // Set current process pointer to head of linked list
+    if (PageIntoList->next != 0)                     // More pages in list
+    {
+      nextPage = PageIntoList->next;
+      nextPage->prev = 0;
+      curProc->pagingMetaData[nextPage->pg.pagesArrayIndex] = *nextPage;
+    }
 
+  }
+
+  PageIntoList->prev = 0;
+  PageIntoList->next = 0;
+
+  // update current process page array
+  curProc->pagingMetaData[PageIntoList->pg.pagesArrayIndex] = *PageIntoList;
+}
+
+/* Delete page from memory */
+int deletePage(struct pageInMemory *pageToDelete)
+{
+  struct proc *curProc = myproc();
+  if (curProc->PhyMemPageCount > 0)
+  {
+    curProc->PhyMemPageCount--;
+  }
+
+  // Initialize page's entry
+  PageInitializeInArray(pageToDelete, (uint)0xFFFFFFFF, NOTUSED);
+
+  /* If any pages on file,
+    then,  bring a page from file into physical memory
+  */
+  if (curProc->FilePagesCount > 0)
+  {
+    struct pageInMemory *bringPageFromFile;
+    int found = 0;
+    for (bringPageFromFile = &curProc->pagingMetaData[0]; bringPageFromFile < &curProc->pagingMetaData[MAX_TOTAL_PAGES]; bringPageFromFile++)
+    {
+      if (bringPageFromFile->pg.state == SWAPFILE)
+      {
+        found = 1;
+        break;
+      }
+    }
+    if (found == 1)
+    {
+      SwapIn(bringPageFromFile);
+    }
+  }
+
+  UpdateRemoveList(pageToDelete);
+
+  curProc->pagingMetaData[pageToDelete->pg.pagesArrayIndex] = *pageToDelete;
+
+  // Print Status
+  cprintf("Delete Page : \n");
+  cprintf("\tProcess : %d , Number of Pages present In Memory = %d\n\n", curProc->pid, curProc->PhyMemPageCount);
+
+  return 0;
+}
